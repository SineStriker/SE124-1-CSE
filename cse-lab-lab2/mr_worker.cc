#include <dirent.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

#include <algorithm>
#include <map>
#include <mutex>
#include <string>
#include <vector>

#include "mr_protocol.h"
#include "rpc.h"

using namespace std;

struct KeyVal {
    string key;
    string val;
};

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content) {
    // Copy your code from mr_sequential.cc here.

    size_t cur = 0, i;
    vector<KeyVal> res;
    while (cur <= content.size()) {
        for (i = cur; i < content.size(); ++i) {
            char ch = content.at(i);
            if (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))) {
                break;
            }
        }
        string str = content.substr(cur, i - cur);
        if (!str.empty()) {
            KeyVal kv;
            kv.key = content.substr(cur, i - cur);
            kv.val = num2str(1);
            res.push_back(kv);
        }

        cur = i + 1;
    }

    return res;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector<string> &values) {
    // Copy your code from mr_sequential.cc here.

    int total = 0;
    for (size_t i = 0; i < values.size(); ++i) {
        total += str2num(values.at(i));
    }

    return num2str(total);
}

typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
    Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

    void doWork();

private:
    void doMap(int index, const vector<string> &filenames);
    void doReduce(int index);
    void doSubmit(mr_tasktype taskType, int index, string dir);

    mutex mtx;
    int id;

    rpcc *cl;
    std::string basedir;
    MAPF mapf;
    REDUCEF reducef;
};

Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf) {
    this->basedir = dir;
    this->mapf = mf;
    this->reducef = rf;

    sockaddr_in dstsock;
    make_sockaddr(dst.c_str(), &dstsock);
    this->cl = new rpcc(dstsock);
    if (this->cl->bind() < 0) {
        printf("mr worker: call bind error\n");
    }
}

void Worker::doMap(int index, const vector<string> &filenames) {
    // Lab2: Your code goes here.

    vector<KeyVal> intermediate;
    for (size_t i = 0; i < filenames.size(); ++i) {
        string filename = filenames.at(i);
        string content;

        // Read the whole file into the buffer.
        getline(ifstream(filename), content, '\0');

        vector<KeyVal> KVA = Map(filename, content);
        intermediate.insert(intermediate.end(), KVA.begin(), KVA.end());
    }

    auto cp = [](KeyVal const &a, KeyVal const &b) { return compare(a.key, b.key); };
    sort(intermediate.begin(), intermediate.end(), cp);

    // Write to map file
    fstream fs;
    fs.open(basedir + "/map" + num2str(index) + ".txt", ios::out);
    if (!fs.fail()) {
        stringstream ss;
        string buf;
        for (size_t i = 0; i < intermediate.size(); ++i) {
            KeyVal kv = intermediate.at(i);
            buf += kv.key + '\n' + kv.val + '\n';
        }
        fs.write(buf.c_str(), buf.size());
        fs.close();

        //cout << "map buf " << index << " " << buf.size() << endl;
    }
}

void Worker::doReduce(int index) {
    // Lab2: Your code goes here.
    fstream fs;
    vector<KeyVal> intermediate;

    // Read from map file
    fs.open(basedir + "/map" + num2str(index) + ".txt", ios::in);
    if (!fs.fail()) {
        string buf;
        readAll(fs, buf);

        stringlist list = split(buf, "\n");

        bool isKey = true;
        KeyVal kv;
        for (auto line : list) {
            if (line.empty()) {
                continue;
            }
            if (isKey) {
                kv.key = line;
            } else {
                kv.val = line;
                intermediate.push_back(kv);
            }
            isKey = !isKey;
        }
        fs.close();
    }

    // Write to reduce file
    fs.open(basedir + "/reduce" + num2str(index) + ".txt", ios::out);
    if (!fs.fail()) {
        string buf;
        for (size_t i = 0; i < intermediate.size();) {
            size_t j = i + 1;
            for (; j < intermediate.size() && intermediate[j].key == intermediate[i].key;) {
                j++;
            }

            vector<string> values;
            for (unsigned int k = i; k < j; k++) {
                values.push_back(intermediate.at(k).val);
            }

            KeyVal kv = intermediate.at(i);
            string output = Reduce(kv.key, values);

            buf += kv.key + '\n' + output + '\n';

            i = j;
        }
        fs.write(buf.c_str(), buf.size());
        fs.close();

       // cout << "buf " << index << " " << buf.size() << endl;
    }
}

void Worker::doSubmit(mr_tasktype taskType, int index, string dir) {
    bool b;
    mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, dir, b);
    if (ret != mr_protocol::OK) {
        fprintf(stderr, "submit task failed\n");
        exit(-1);
    }
}

void Worker::doWork() {
    for (;;) {

        //
        // Lab2: Your code goes here.
        // Hints: send asktask RPC call to coordinator
        // if mr_tasktype::MAP, then doMap and doSubmit
        // if mr_tasktype::REDUCE, then doReduce and doSubmit
        // if mr_tasktype::NONE, meaning currently no work is needed, then sleep
        //
        int r;
        mr_protocol::AskTaskResponse t;
        mr_protocol::status ret = cl->call(mr_protocol::asktask, r, t);
        if (ret != mr_protocol::OK) {
            fprintf(stderr, "ask task failed\n");
            exit(-1);
        }

        int type = t.type;
        int index = t.index;

        switch (type) {
        case MAP:
            //cout << index << " " << type << " " << basedir << endl;
            doMap(index, t.filenames);
            doSubmit(MAP, index, basedir);
            //cout << "submit map " << index << endl;
            break;
        case REDUCE:
            //cout << index << " " << type << " " << basedir << endl;
            doReduce(index);
            doSubmit(REDUCE, index, basedir);
            //cout << "submit reduce" << index << endl;
            break;
        default:
            usleep(100000);
            break;
        }
    }
}

int main(int argc, char **argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
        exit(1);
    }

    MAPF mf = Map;
    REDUCEF rf = Reduce;

    char *chDir = get_current_dir_name();
    string sDir(chDir);
    free(chDir);

    string rPath(argv[2]);
    if (rPath.front() != '/') {
        if (rPath.substr(0, 2) == "./") {
            rPath = rPath.substr(2);
        }
        rPath = sDir + '/' + rPath;
    }

    Worker w(argv[1], rPath, mf, rf);
    w.doWork();

    return 0;
}
